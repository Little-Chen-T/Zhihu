# 1. 题目
我们称一个数字字符串是**好数字**当它满足（下标从 0 开始）**偶数下标处的数字为偶数且奇数下标处的数字为质数** （2，3，5 或 7）。

比方说，"2582" 是好数字，因为偶数下标处的数字（2 和 8）是偶数且奇数下标处的数字（5 和 2）为质数。但 "3245" 不是 好数字，因为 3 在偶数下标处但不是偶数。

给你一个整数 n ，请你返回长度为 n 且为好数字的数字字符串 总数 。由于答案可能会很大，请你将它对${10^9+7}$ 取余后返回 。

一个**数字字符串**是每一位都由 0 到 9 组成的字符串，且可能**包含**前导 0 。

> 示例 1：
> 
> 输入：n = 1 
> 输出：5 
> 解释：长度为 1 的好数字包括 "0"，"2"，"4"，"6"，"8" 。 

> 示例 2：
> 
> 输入：n = 4 
> 输出：400 

> 示例 3：
> 
> 输入：n = 50 
> 输出：564908303

提示：

${1\leq n\leq10^{15}}$

# 2. 解题思路
这一题乍看很像暴力求解，但是再看数据量呢，远远超过${10^7}$，用暴力必然会超时。

仔细分析题目的条件，**偶数位上满足是偶数，奇数位上满足是质数，同时包括首位是0的情况**，那这不就是简单的乘法吗？

>偶数位要求是偶数，单个数字是偶数的就5个，0，2，4，6，8
>奇数位要求是质数，单个数字是质数的就4个，2，3，5，7

所以要求n位数的好数有多少个，不就是数有多少个偶数位和多少个奇数位吗，每个偶数位有5种情况（选择0，2，4，6，8中的某一个，所以有5种选择），每个奇数位有4种情况（2，3，5，7）。所以一共满足条件的数的个数就满足如下关系：

> ${len\_of\_even}$代表偶数位个数
> ${len\_of\_odd}$代表奇数位个数
> 总个数${total = 5^{len\_of\_even}*4^{len\_of\_odd}}$

这题就这么简单吗？看看数据量呢，${1\leq n\leq10^{15}}$，无论是用for循环还是普通递归去计算都会超时或者${stack-overflow}$。所以这题应该用**快速幂**。在我的另一篇文章中有详细讲解（[蓝桥杯冲刺训练营之递归——例2.pow函数](https://blog.csdn.net/qq_32614873/article/details/122960694?spm=1001.2014.3001.5501)）。

对于上述公式可以进一步进行化简成20的幂函数，只需要判断n是奇数还是偶数，通过简单推到可得到如下公式：


$$ total=\left\{
\begin{array}{lcl}
5             & & {n == 1}\\
20^{n/2}  & & { n是偶数} \\
5*20^{n/2} & & {n是奇数} \\
\end{array}
\right.
$$

# 3. 代码
```cpp
class Solution {
public:

    long long  NUM = 1000000007;

    map<long long, long long > table;

    long long myPow(long long x, long long n){

        if (n == 0) return 1;
        if (n == 1) return x;

        long long ans;

        //奇数 = x*x^(n/2)*x^(n/2)
        //偶素 = x^(n/2)*x^(n/2)

        if(n%2==0){
            if(table.find(n/2) == table.end()){
                table[n/2] = myPow(x, n/2)%NUM;
            }

            ans = table[n/2]*table[n/2]%NUM;
            table[n] = ans;
        }
        else{

            if(table.find(n/2) == table.end()){
                table[n/2] = myPow(x, n/2)%NUM;
            }

            ans = x*table[n/2]%NUM*table[n/2]%NUM;
            table[n] = ans;
        }

        return ans;
    }
    
    int countGoodNumbers(long long n) {

        long long ans;

        if (n == 1) return 5;

        //奇数是pow(20,n/2)*5
        //偶数是pow(20, n/2)

        if(n%2!=0){
            ans = myPow(20, n/2)*5%NUM;
        }
        else{
            ans = myPow(20, n/2)%NUM;
        }

        return ans%NUM;
    }
};
```

